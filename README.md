# Data Structures and Algorithms in JavaScript

ðŸ˜‰ Learning Datastructures and Algorithms

## Prerequisites

- Node.js version 12.0 or higher
- npm (included with Node.js)

## Big-O

Big-O notation is a way of expressing the time complexity of algorithms. It is a measure of the performance of an algorithm, specifically the number of operations it takes to complete.

In general, the time complexity of an algorithm is a function of the size of the input, denoted as "n" in Big-O notation. For example, if an algorithm takes twice as long to run on an input of size n as it does on an input of size n/2, the time complexity is O(n).

Big-O notation can be used to describe the worst-case, average-case, or best-case time complexity of an algorithm. For example, if an algorithm has a worst-case time complexity of O(n^2), it means that for the worst-case input, the algorithm will take n^2 operations to complete.

Some common time complexities in Big-O notation are:

- O(1) - Constant time complexity. The algorithm takes the same amount of time to run regardless of the size of the input.
- O(log n) - Logarithmic time complexity. The algorithm's running time increases at a slower rate as the size of the input increases.
- O(n) - Linear time complexity. The algorithm's running time is directly proportional to the size of the input.

## Big-O Trend

![Big-O Trend](https://github.com/Kishore025/DataStructures-And-Algorithms/blob/master/Cheatsheet/2-BigOTrend.png)

## Data Structures

- Array
- Object
- Set
- Map
- Linked List
- Stack
- Queue
- Heap
- Tree
- Graph
- Hash Table

## Algorithms

- Sorting algorithms (e.g. bubble sort, merge sort, quick sort)
- Search algorithms (e.g. linear search, binary search)
- Tree traversal algorithms (e.g. in-order, pre-order, post-order)
- Graph traversal algorithms (e.g. breadth-first search, depth-first search)
- Dynamic programming algorithms (e.g. knapsack problem, shortest path)
- Recursion
- Bit manipulation
- Greedy algorithms
- Backtracking
